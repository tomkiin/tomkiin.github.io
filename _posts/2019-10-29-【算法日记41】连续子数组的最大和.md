#### **题目描述**

> HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)

#### **题目思路**

保存每次都累加和，如果累加和的值为负数，那么它肯定会让下一次累加的结果变小，因此我们就跳过前面累加和为负数的子数组，从后面开始遍历。每次遍历的时候，要把最大值保存到一个变量中，防止后面的负数减少了最大累加和。

例如，计算 {6,-3,-2,7,-15,1,2,2} 的过程如下



| 操作                            | currentSum | maxSum |
| ------------------------------- | ---------- | ------ |
| +6                              | 6          | 6      |
| -3                              | 3          | 6      |
| -2                              | 1          | 6      |
| +7                              | 8          | 8      |
| -15                             | -7         | 8      |
| 抛弃前面和为-7的子数组，从1开始 | 1          | 8      |
| +2                              | 3          | 8      |
| +2                              | 5          | 8      |

返回结果，8

#### 题目代码

```java
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        if (array == null || array.length == 0) return 0;
        int currentSum = 0;
        int maxSum = Integer.MIN_VALUE;
        for (int num: array) {
            if (currentSum < 0)
                currentSum = num;
            else
                currentSum += num;
            if (currentSum > maxSum)
                maxSum = currentSum;
        }
        return maxSum;
    }
}
```

